
[{"content":"","date":"21 August 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"I decided to blog this on as I found that the general articles seems to be missing a few steps, which makes getting a new server repo working properly. So this guide is a reminder to me (primarily).\nAt the server (which we call server01.sr)\n# sudo adduser git # su - git $ cd /home/git $ mkdir .ssh \u0026amp;\u0026amp; chmod 700 .ssh $ touch .ssh/authorized_keys \u0026amp;\u0026amp; chmod 600 .ssh/authorized_keys You\u0026rsquo;ll need to have your own ssh keys in order to login to the server. To create pair of keys (a pair consist of a private key and a public key. The command below will create a keypair using RSA as the default algorithm.\n$ ssh-keygen But if you\u0026rsquo;re like me and you like better stronger crypto, you\u0026rsquo;d be using ECC (Elliptic Curve Cryptography), and in this example I use ED25519. The -C parameter is a comment on the key, in the event you mabage multiple keys. It will create 2 files - id_rsa and id_rsa.pub.\n$ ssh-keygen -t ED25519 -C \u0026#34;My-Test-Key\u0026#34; For the newly created ED25519 keys, the filenames are namely id_ed25519 and ud_25519.pub . As you may have guessed, the file with the extension .pub is the public key file, which you will use. Copy the contents and paste it into the server\u0026rsquo;s /home/git/.ssh/authorized_keys. Alternatively you can automatically place the keys using ssh-copy-id command. At your client\u0026rsquo;s machine which you just generated the keypair\u0026hellip;\n$ ssh-copy-d -i /Users/yourleetuser/.ssh/id_ed25519 git@server01.sr Note that the public keys needs to be part of git user in the server.\nNow that the keys are in and you can verify by ssh into your server. It shouldn\u0026rsquo;t ask you for passwords and log you in. If there is trouble, and you have rsyslog enabled in your server, you can refer to /var/log/auth.log for authentication/ssh troubleshooting.\nNow, on your machine, lets make some global configuration settings.\ngit config --global init.defaultBranch main This will set the default initial branch to \u0026ldquo;main\u0026rdquo;. You can use anything for that, i.e. master, etc.\nNow, lets get to the part where we create the repo. Our repo will be mydev.git\n# su - git $ mkdir mydev.git $ cd mydev.git $ git init --initial-branch main Since we have already set the default initial branch, we can omit \u0026ndash;initial-branch (unless if you want to specify a different branch).\nNow at your development machine, you can start by initialise the directory at the local machine. The assumption is that SSH is running on the default port 22.\n$ git clone ssh://git@server01.sr/home/git/mydev.git $ cd mydev At this point you can start adding/editing files inside the local mydev directory. Once done\u0026hellip;\n$ git add . $ git commit -m \u0026#34;Initial commit\u0026#34; $ git push origin main Now your source code is synchronised to your git repository.\n","date":"21 August 2025","externalUrl":null,"permalink":"/posts/newgit/","section":"Posts","summary":"","title":"Setting up own Git server","type":"posts"},{"content":"","date":"21 August 2025","externalUrl":null,"permalink":"/","section":"Technology @ DrSuresh.NET","summary":"","title":"Technology @ DrSuresh.NET","type":"page"},{"content":"I needed a good guide on deploying the PFUG stack as I now do that often (it helps me with rapid prototyping and MVP).\nThis guide provides comprehensive instructions for deploying a Python/Flask application in production using uv for dependency management and Gunicorn as the WSGI server.\nPrerequisites # Ubuntu/Debian-based server (adaptable to other Linux distributions) Python 3.8 or higher Sudo access Domain name (optional but recommended) 1. System Preparation # Update system packages # sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Install required system dependencies # sudo apt install -y python3-dev python3-pip build-essential nginx supervisor curl Install uv (Python package manager) # curl -LsSf https://astral.sh/uv/install.sh | sh source $HOME/.cargo/env 2. Application Setup # Create application user and directory # # Create dedicated user for the application sudo useradd -m -s /bin/bash flaskapp sudo usermod -aG sudo flaskapp # Create application directory sudo mkdir -p /opt/flask-app sudo chown flaskapp:flaskapp /opt/flask-app Switch to application user and setup directory # sudo -u flaskapp -i cd /opt/flask-app Clone your application (replace with your repository) # # Example - replace with your actual repository git clone https://github.com/yourusername/your-flask-app.git . # OR upload your application files to this directory 3. Python Environment Setup with uv # Initialize uv project and install dependencies # # Initialize uv in the project directory uv init --no-readme # Install Flask and Gunicorn uv add flask gunicorn # Install your application dependencies # If you have a requirements.txt: uv pip install -r requirements.txt # Or install specific packages: # uv add requests psycopg2-binary redis etc. Create pyproject.toml for dependency management # [project] name = \u0026#34;flask-app\u0026#34; version = \u0026#34;1.0.0\u0026#34; description = \u0026#34;Production Flask Application\u0026#34; requires-python = \u0026#34;\u0026gt;=3.8\u0026#34; dependencies = [ \u0026#34;flask\u0026gt;=2.3.0\u0026#34;, \u0026#34;gunicorn\u0026gt;=21.2.0\u0026#34;, # Add your other dependencies here ] [build-system] requires = [\u0026#34;hatchling\u0026#34;] build-backend = \u0026#34;hatchling.build\u0026#34; 4. Application Configuration # Create Gunicorn configuration file # Create /opt/flask-app/gunicorn_config.py:\nimport multiprocessing import os # Server socket bind = \u0026#34;127.0.0.1:8000\u0026#34; backlog = 2048 # Worker processes workers = multiprocessing.cpu_count() * 2 + 1 worker_class = \u0026#34;sync\u0026#34; worker_connections = 1000 timeout = 30 keepalive = 2 # Restart workers after this many requests, to help prevent memory leaks max_requests = 1000 max_requests_jitter = 100 # Process naming proc_name = \u0026#39;flask-app\u0026#39; # Logging accesslog = \u0026#39;/var/log/flask-app/access.log\u0026#39; errorlog = \u0026#39;/var/log/flask-app/error.log\u0026#39; loglevel = \u0026#39;info\u0026#39; # Process identification pidfile = \u0026#39;/opt/flask-app/gunicorn.pid\u0026#39; # User and group user = \u0026#39;flaskapp\u0026#39; group = \u0026#39;flaskapp\u0026#39; # Preload application for better performance preload_app = True # Environment variables raw_env = [ \u0026#39;FLASK_ENV=production\u0026#39;, \u0026#39;PYTHONPATH=/opt/flask-app\u0026#39;, ] Create environment configuration # Create /opt/flask-app/.env:\n# Flask Configuration FLASK_APP=app.py FLASK_ENV=production SECRET_KEY=your-super-secret-key-change-this # Database Configuration (if using database) DATABASE_URL=postgresql://user:password@localhost/dbname # Other environment variables # REDIS_URL=redis://localhost:6379/0 # MAIL_SERVER=smtp.gmail.com Create log directories # sudo mkdir -p /var/log/flask-app sudo chown flaskapp:flaskapp /var/log/flask-app 5. Supporting Scripts # Deployment Script # Create /opt/flask-app/deploy.sh:\n#!/bin/bash # Flask Application Deployment Script set -e APP_DIR=\u0026#34;/opt/flask-app\u0026#34; APP_USER=\u0026#34;flaskapp\u0026#34; echo \u0026#34;Starting deployment...\u0026#34; # Navigate to app directory cd $APP_DIR # Pull latest changes (if using git) echo \u0026#34;Pulling latest changes...\u0026#34; sudo -u $APP_USER git pull origin main # Update dependencies echo \u0026#34;Updating dependencies...\u0026#34; sudo -u $APP_USER uv sync # Run database migrations (if applicable) # echo \u0026#34;Running database migrations...\u0026#34; # sudo -u $APP_USER uv run flask db upgrade # Collect static files (if applicable) # echo \u0026#34;Collecting static files...\u0026#34; # sudo -u $APP_USER uv run python manage.py collectstatic --noinput # Restart services echo \u0026#34;Restarting services...\u0026#34; sudo supervisorctl restart flask-app sudo systemctl reload nginx echo \u0026#34;Deployment completed successfully!\u0026#34; Health Check Script # Create /opt/flask-app/health_check.sh:\n#!/bin/bash # Health check script for Flask application APP_URL=\u0026#34;http://127.0.0.1:8000\u0026#34; HEALTH_ENDPOINT=\u0026#34;/health\u0026#34; # Implement this endpoint in your Flask app # Check if Gunicorn process is running if ! pgrep -f \u0026#34;gunicorn.*flask-app\u0026#34; \u0026gt; /dev/null; then echo \u0026#34;ERROR: Gunicorn process not found\u0026#34; exit 1 fi # Check HTTP response HTTP_CODE=$(curl -s -o /dev/null -w \u0026#34;%{http_code}\u0026#34; ${APP_URL}${HEALTH_ENDPOINT} || echo \u0026#34;000\u0026#34;) if [ \u0026#34;$HTTP_CODE\u0026#34; = \u0026#34;200\u0026#34; ]; then echo \u0026#34;OK: Application is healthy\u0026#34; exit 0 else echo \u0026#34;ERROR: HTTP $HTTP_CODE - Application health check failed\u0026#34; exit 1 fi Backup Script # Create /opt/flask-app/backup.sh:\n#!/bin/bash # Backup script for Flask application BACKUP_DIR=\u0026#34;/opt/backups\u0026#34; APP_DIR=\u0026#34;/opt/flask-app\u0026#34; DATE=$(date +%Y%m%d_%H%M%S) # Create backup directory mkdir -p $BACKUP_DIR # Backup application files echo \u0026#34;Backing up application files...\u0026#34; tar -czf \u0026#34;$BACKUP_DIR/flask-app-$DATE.tar.gz\u0026#34; -C /opt flask-app # Backup database (PostgreSQL example) # echo \u0026#34;Backing up database...\u0026#34; # sudo -u postgres pg_dump your_database \u0026gt; \u0026#34;$BACKUP_DIR/database-$DATE.sql\u0026#34; # Clean old backups (keep last 7 days) find $BACKUP_DIR -name \u0026#34;flask-app-*.tar.gz\u0026#34; -mtime +7 -delete # find $BACKUP_DIR -name \u0026#34;database-*.sql\u0026#34; -mtime +7 -delete echo \u0026#34;Backup completed: flask-app-$DATE.tar.gz\u0026#34; Make scripts executable:\nchmod +x /opt/flask-app/deploy.sh chmod +x /opt/flask-app/health_check.sh chmod +x /opt/flask-app/backup.sh 6. Process Management with Supervisor # Install and configure Supervisor # sudo apt install supervisor -y Create /etc/supervisor/conf.d/flask-app.conf:\n[program:flask-app] command=/home/flaskapp/.local/bin/uv run gunicorn -c gunicorn_config.py app:app directory=/opt/flask-app user=flaskapp autostart=true autorestart=true redirect_stderr=true stdout_logfile=/var/log/flask-app/supervisor.log environment=PATH=\u0026#34;/home/flaskapp/.local/bin:/usr/local/bin:/usr/bin:/bin\u0026#34; Note: Do not daemonise gunicorn with \u0026ndash;daemon. That will be handled by Supervisor.\nStart and enable Supervisor # sudo systemctl enable supervisor sudo systemctl start supervisor sudo supervisorctl reread sudo supervisorctl update sudo supervisorctl start flask-app 7. Nginx Reverse Proxy Setup # Create /etc/nginx/sites-available/flask-app:\nserver { listen 80; server_name your-domain.com www.your-domain.com; # Replace with your domain # Security headers add_header X-Frame-Options \u0026#34;SAMEORIGIN\u0026#34; always; add_header X-XSS-Protection \u0026#34;1; mode=block\u0026#34; always; add_header X-Content-Type-Options \u0026#34;nosniff\u0026#34; always; add_header Referrer-Policy \u0026#34;no-referrer-when-downgrade\u0026#34; always; # Rate limiting limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s; limit_req zone=api burst=20 nodelay; # Static files (if you have them) location /static { alias /opt/flask-app/static; expires 1y; add_header Cache-Control \u0026#34;public, immutable\u0026#34;; } # Main application location / { proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; # Timeouts proxy_connect_timeout 60s; proxy_send_timeout 60s; proxy_read_timeout 60s; # Buffer settings proxy_buffering on; proxy_buffer_size 128k; proxy_buffers 4 256k; proxy_max_temp_file_size 1024m; } # Health check endpoint location /health { proxy_pass http://127.0.0.1:8000; access_log off; } } Enable the site # sudo ln -s /etc/nginx/sites-available/flask-app /etc/nginx/sites-enabled/ sudo nginx -t sudo systemctl restart nginx 8. SSL Certificate with Certbot (Optional but Recommended) # # Install Certbot sudo apt install certbot python3-certbot-nginx -y # Obtain SSL certificate sudo certbot --nginx -d your-domain.com -d www.your-domain.com # Auto-renewal is set up automatically sudo certbot renew --dry-run 9. Monitoring and Maintenance # Set up log rotation # Create /etc/logrotate.d/flask-app:\n/var/log/flask-app/*.log { daily missingok rotate 52 compress delaycompress notifempty create 644 flaskapp flaskapp postrotate supervisorctl restart flask-app endscript } Cron jobs for maintenance # Add to crontab (sudo crontab -e):\n# Daily backup at 2 AM 0 2 * * * /opt/flask-app/backup.sh # Health check every 5 minutes */5 * * * * /opt/flask-app/health_check.sh # Log rotation 0 0 * * * /usr/sbin/logrotate /etc/logrotate.d/flask-app 10. Deployment Commands # Initial deployment # # Start services sudo supervisorctl start flask-app sudo systemctl start nginx # Check status sudo supervisorctl status sudo systemctl status nginx Updates and maintenance # # Deploy updates ./deploy.sh # Check application status sudo supervisorctl status flask-app # View logs sudo supervisorctl tail -f flask-app tail -f /var/log/flask-app/error.log # Restart application sudo supervisorctl restart flask-app Troubleshooting # Common issues and solutions # Permission denied errors: Ensure correct ownership of files\nsudo chown -R flaskapp:flaskapp /opt/flask-app Port already in use: Check for conflicting processes\nsudo lsof -i :8000 502 Bad Gateway: Check Gunicorn is running and accessible\ncurl http://127.0.0.1:8000 View application logs:\ntail -f /var/log/flask-app/error.log sudo supervisorctl tail -f flask-app Security Considerations # Firewall configuration:\nsudo ufw allow ssh sudo ufw allow \u0026#39;Nginx Full\u0026#39; sudo ufw enable Keep system updated:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Regular security audits:\nuv pip audit Environment variables: Never commit secrets to version control\nDatabase security: Use strong passwords and limit access\nThis production setup provides a robust, scalable foundation for your Flask application with proper process management, reverse proxy, SSL termination, and monitoring capabilities.\n","date":"28 July 2025","externalUrl":null,"permalink":"/posts/pfug/","section":"Posts","summary":"","title":"Python + Flask + Gunicorn - using uv","type":"posts"},{"content":"I never thought that a virtual environment would break. But here we are. This is my story.\nI had a server that was long overdue for OS upgrade. It had been running Debian 11 for long time, and rightfully so as the critical package was only supported on Debian 11. Today, I happen to do some maintenance and found out that I am now free to move to Debian 12. And thats when trouble started (why does this happen to me?)\nSo, I used apt to upgrade the packages, then the OS, and then finally the packages again just to make sure everything runs on the new OS version. All worked well. Sort off.\nI had a site that was running on Python-Flask-Gunicorn. Site was down. Logged in to check, to find that gunicorn wasn\u0026rsquo;t running. Okay, no biggie, I just go in and start the service. I got a bunch of errors saying that pip wasn\u0026rsquo;t available. Tried running pip manually, didn\u0026rsquo;t work. Exited the virtualenv, the OS version of pip was working fine. Nothing worked because the scripts were calling pip inside the virtualenv.\nSo, Hail Mary and decided to create a new virtual environment and run \u0026ldquo;pip install -r requirements.txt\u0026rdquo; (kids make sure your requirements.txt file is in working condition!). Made changes to my gunicorn helper scripts and viola! it worked! It\u0026rsquo;s alive!!!\nSo, today I learnt that OS upgrade breaks Python\u0026rsquo;s virtual environment. It seems (and I don\u0026rsquo;t know how) that the OS binding of Python has an influence to the virtualenvironment.\n","date":"9 July 2025","externalUrl":null,"permalink":"/posts/venvbroke/","section":"Posts","summary":"","title":"The day when my Python Virtual Environment broke","type":"posts"},{"content":" Another beginning # For most of you who knows me, you know I already have a master website. So why another one?\nSimplistic term, because I can!\nMore longer explanation, I wanted to declutter my brains. The main website serves as it is, a brain diarheaa of thoughts which is more structured towards work/cyber and general tech discussions. You\u0026rsquo;d see my thoughts and views on current and potentially future events. While that appeals to the general John Q. Public, I am very much a tech hands-on legs deep in mud kinda person.\nI started off my career being very technical, as in a keyboard junkie some might say, and true till today I still am. Doing all the tinkering, setting things up, learning more and more as I can. So I realised that knowledge, not used over time will erode. Connection between braincells deteriorate and I wanted an outlet which I could retain my learnt knowledge. Enter this site.\nWhy 2 and not 1? # I will be publishing in both, truth be told. I wanted the tech/config/deep stuff to be in a separate site so that it becomes easier when I wanted to search for things. Call it SR\u0026rsquo;s simple way of organizing information. Its also intended to keep some knowledge in my personal vault so that it\u0026rsquo;s accessible when I need it.\nAnd so it shall begin!\n","date":"1 February 2025","externalUrl":null,"permalink":"/posts/genesis/","section":"Posts","summary":"","title":"Genesis","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]